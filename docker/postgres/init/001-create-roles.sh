#!/usr/bin/env bash
set -euo pipefail

if [[ -z "${POSTGRES_DB:-}" ]]; then
  echo "POSTGRES_DB is required" >&2
  exit 1
fi

QS_DB_MIGRATE_USER="${QS_DB_MIGRATE_USER:-qs_migrate}"
QS_DB_RUNTIME_USER="${QS_DB_RUNTIME_USER:-qs_runtime}"

if [[ -z "${QS_DB_MIGRATE_PASSWORD:-}" || -z "${QS_DB_RUNTIME_PASSWORD:-}" ]]; then
  echo "QS_DB_MIGRATE_PASSWORD and QS_DB_RUNTIME_PASSWORD are required" >&2
  exit 1
fi

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<SQL
DO \$\$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = '${QS_DB_MIGRATE_USER}') THEN
    -- IMPORTANT: The migrations role bypasses RLS and is intended ONLY for schema migrations
    -- and test/CI cleanup. Never use this role for application runtime credentials.
    CREATE ROLE ${QS_DB_MIGRATE_USER} LOGIN PASSWORD '${QS_DB_MIGRATE_PASSWORD}' BYPASSRLS;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = '${QS_DB_RUNTIME_USER}') THEN
    CREATE ROLE ${QS_DB_RUNTIME_USER} LOGIN PASSWORD '${QS_DB_RUNTIME_PASSWORD}';
  END IF;
END
\$\$;

GRANT CONNECT ON DATABASE ${POSTGRES_DB} TO ${QS_DB_MIGRATE_USER};
GRANT CONNECT ON DATABASE ${POSTGRES_DB} TO ${QS_DB_RUNTIME_USER};
GRANT CREATE ON DATABASE ${POSTGRES_DB} TO ${QS_DB_MIGRATE_USER};

GRANT USAGE, CREATE ON SCHEMA public TO ${QS_DB_MIGRATE_USER};
GRANT USAGE ON SCHEMA public TO ${QS_DB_RUNTIME_USER};

ALTER DEFAULT PRIVILEGES FOR ROLE ${QS_DB_MIGRATE_USER} IN SCHEMA public
  GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO ${QS_DB_RUNTIME_USER};

ALTER DEFAULT PRIVILEGES FOR ROLE ${QS_DB_MIGRATE_USER} IN SCHEMA public
  GRANT USAGE, SELECT ON SEQUENCES TO ${QS_DB_RUNTIME_USER};
SQL
