---
phase: 14-monetization
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - apps/api/src/trial/trial.module.ts
  - apps/api/src/trial/trial.service.ts
  - apps/api/src/trial/__tests__/trial.service.unit.test.ts
  - apps/api/src/features/features.service.ts
  - apps/api/src/features/features.module.ts
  - apps/api/src/features/__tests__/features.service.unit.test.ts
  - apps/api/src/auth/auth.controller.ts
  - apps/api/src/auth/auth.module.ts
  - apps/api/src/app.module.ts
autonomous: true
must_haves:
  truths:
    - "First login for a new org creates org_subscriptions row with tier=pro and trialEndsAt=now+14days"
    - "Subsequent logins for same org do not reset the trial"
    - "FeaturesService reads tier from org_subscriptions, not tenants.subscriptionTier"
    - "When trial is expired and no Stripe subscription exists, FeaturesService returns tier=free"
    - "Features API response includes trial state (active, daysRemaining, endsAt)"
    - "Trial activation race condition prevented by INSERT ON CONFLICT DO NOTHING"
    - "Seat limit read from org_subscriptions, not tenants.seatLimit"
  artifacts:
    - path: "apps/api/src/trial/trial.service.ts"
      provides: "Trial activation and status checking logic"
      exports: ["TrialService"]
    - path: "apps/api/src/trial/trial.module.ts"
      provides: "NestJS TrialModule"
      exports: ["TrialModule"]
    - path: "apps/api/src/features/features.service.ts"
      provides: "Refactored FeaturesService reading from org_subscriptions"
      contains: "orgSubscriptionRepo"
    - path: "apps/api/src/auth/auth.controller.ts"
      provides: "Trial activation call after tenant upsert in login flow"
      contains: "trialService"
  key_links:
    - from: "apps/api/src/auth/auth.controller.ts"
      to: "apps/api/src/trial/trial.service.ts"
      via: "activateTrial() call after handleJwtLogin/handleCallback"
      pattern: "trialService\\.activateTrial"
    - from: "apps/api/src/features/features.service.ts"
      to: "packages/database/src/repositories/drizzle-repositories.ts"
      via: "orgSubscriptionRepo.findByTenantId for tier lookup"
      pattern: "orgSubscriptionRepo\\.findByTenantId"
    - from: "apps/api/src/features/features.service.ts"
      to: "packages/shared-types/src/features.ts"
      via: "TrialState in response"
      pattern: "TrialState|trial:"
---

<objective>
Implement the reverse free trial lifecycle and refactor FeaturesService to read tier from org_subscriptions.

Purpose: The trial is the primary monetization strategy -- new orgs experience full Pro value for 14 days, then drop to Free. This plan wires trial activation into the auth flow and makes FeaturesService the single source of truth for tier determination, reading from org_subscriptions instead of the legacy tenants.subscriptionTier column.

Output: TrialModule (activation + status), refactored FeaturesService, auth flow integration, and unit tests.

Note on seat enforcement (MON-02): The CONTEXT.md locked decision specifies "explicit admin assignment -- admin buys N seats, assigns specific users" with overflow users getting Free mode. Full enforcement requires: (1) a seat assignment table to track which users hold seats, (2) admin UI for seat management, (3) per-user tier resolution in FeaturesService. This plan stores seatLimit in org_subscriptions and reads it, but per-user seat enforcement is deferred to a dedicated future plan since the admin assignment UI and per-user seat tracking table are not in scope for Phase 14. The existing SeatLimitService (in backend-shared) continues to provide basic count-based blocking during auth for new users as a safety net.
</objective>

<execution_context>
@/home/blakebrooks-88/.claude/get-shit-done/workflows/execute-plan.md
@/home/blakebrooks-88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-monetization/14-CONTEXT.md
@.planning/phases/14-monetization/14-RESEARCH.md
@.planning/phases/14-monetization/14-01-SUMMARY.md
@apps/api/src/features/features.service.ts
@apps/api/src/features/features.module.ts
@apps/api/src/auth/auth.controller.ts
@apps/api/src/auth/auth.module.ts
@packages/backend-shared/src/auth/auth.service.ts
@packages/database/src/interfaces/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TrialService and integrate trial activation into auth flow</name>
  <files>
    apps/api/src/trial/trial.module.ts
    apps/api/src/trial/trial.service.ts
    apps/api/src/trial/__tests__/trial.service.unit.test.ts
    apps/api/src/auth/auth.controller.ts
    apps/api/src/auth/auth.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
    **Step 1: Create apps/api/src/trial/trial.service.ts**

    Injectable service with these methods:

    `activateTrial(tenantId: string): Promise<void>`
    - Uses the `insertIfNotExists` method from IOrgSubscriptionRepository (defined in Plan 14-01)
    - Creates org_subscriptions row with: tenantId, tier = "pro", trialEndsAt = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), seatLimit = null (unlimited during trial)
    - The insertIfNotExists method uses INSERT ON CONFLICT (tenant_id) DO NOTHING to prevent race conditions when two users from the same org log in simultaneously (per research pitfall #5)
    - Important: Do NOT use DO UPDATE -- if a subscription already exists (trial or paid), do not overwrite it
    - Log audit event `subscription.trial_activated` via AuditService
    - If the row already exists, the INSERT silently does nothing -- no error, no update

    `getTrialState(tenantId: string): Promise<TrialState | null>`
    - Query org_subscriptions by tenantId
    - If no row exists, return null
    - If trialEndsAt is null (paid subscription, not trial), return null
    - If trialEndsAt is in the future: active = true, daysRemaining = ceil((trialEndsAt - now) / (24*60*60*1000)), endsAt = trialEndsAt.toISOString()
    - If trialEndsAt is in the past: active = false, daysRemaining = 0, endsAt = trialEndsAt.toISOString()

    Constructor injects:
    - ORG_SUBSCRIPTION_REPOSITORY (IOrgSubscriptionRepository)
    - AuditService
    - Logger

    **Step 2: Create apps/api/src/trial/trial.module.ts**

    NestJS module:
    - Imports: DatabaseModule, AuditModule
    - Providers: TrialService, ORG_SUBSCRIPTION_REPOSITORY factory (same pattern as other modules)
    - Exports: TrialService

    **Step 3: Update apps/api/src/auth/auth.controller.ts**

    Inject TrialService into AuthController constructor.

    In the `loginPost` method, after `const { user, tenant, mid } = await this.authService.handleJwtLogin(jwt);` and before session setup, add:
    ```typescript
    // Activate trial for new orgs (idempotent -- no-op if subscription exists)
    await this.trialService.activateTrial(tenant.id);
    ```

    In the `login` method (GET), in the block where JWT is present and handleJwtLogin succeeds, add the same call:
    ```typescript
    await this.trialService.activateTrial(tenant.id);
    ```

    In the `callback` method, after `const result = await this.authService.handleCallback(...)` and before session setup, add:
    ```typescript
    await this.trialService.activateTrial(result.tenant.id);
    ```

    Important: activateTrial is idempotent and fast (single INSERT that no-ops on conflict). It runs on EVERY login, not just the first. This is simpler than checking "is this the first login" and handles edge cases cleanly.

    **Step 4: Update apps/api/src/auth/auth.module.ts**

    Import TrialModule in AuthModule's imports array so TrialService is available for injection.

    **Step 5: Add TrialModule to apps/api/src/app.module.ts**

    Import TrialModule in AppModule's imports array.

    **Step 6: Create apps/api/src/trial/__tests__/trial.service.unit.test.ts**

    Test cases:
    1. **New org trial**: When insertIfNotExists returns true, verify audit event logged with `subscription.trial_activated`. Verify trialEndsAt is ~14 days from now.
    2. **Existing subscription**: When insertIfNotExists returns false, verify NO audit event logged (trial already exists or paid subscription).
    3. **getTrialState active**: When trialEndsAt is 5 days in future, returns { active: true, daysRemaining: 5, endsAt: "..." }.
    4. **getTrialState expired**: When trialEndsAt is 2 days in past, returns { active: false, daysRemaining: 0, endsAt: "..." }.
    5. **getTrialState paid**: When trialEndsAt is null (paid sub), returns null.
    6. **getTrialState no subscription**: When no org_subscriptions row, returns null.
    7. **Race condition safety**: Two concurrent activateTrial calls both succeed without error (the second is a no-op).

    Use vi.fn() for repository methods and Date.now mocking for time-dependent tests (same pattern as existing tests -- mock Date.now, not vi.useFakeTimers).
  </action>
  <verify>
    - `pnpm typecheck` passes
    - `pnpm --filter api test` passes (trial service tests + existing auth tests)
    - `pnpm lint` passes
    - Auth controller compiles with TrialService injection
  </verify>
  <done>
    TrialService activates 14-day Pro trial on first login (idempotent, race-safe). Auth flow calls activateTrial after every successful login. Unit tests cover all trial states and edge cases.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor FeaturesService to read from org_subscriptions and include trial state</name>
  <files>
    apps/api/src/features/features.service.ts
    apps/api/src/features/features.module.ts
    apps/api/src/features/__tests__/features.service.unit.test.ts
  </files>
  <action>
    **Step 1: Refactor apps/api/src/features/features.service.ts**

    Add new constructor dependencies:
    - @Inject('ORG_SUBSCRIPTION_REPOSITORY') private orgSubscriptionRepo: IOrgSubscriptionRepository
    - private trialService: TrialService

    Refactor `getTenantFeatures(tenantId: string)`:

    ```typescript
    async getTenantFeatures(tenantId: string): Promise<TenantFeaturesResponse> {
      const tenant = await this.tenantRepo.findById(tenantId);
      if (!tenant) {
        throw new AppError(ErrorCode.RESOURCE_NOT_FOUND, ...);
      }

      // Read tier from org_subscriptions (new source of truth)
      const subscription = await this.orgSubscriptionRepo.findByTenantId(tenantId);

      // Determine effective tier:
      // 1. If subscription exists and has active Stripe subscription -> use subscription tier
      // 2. If subscription exists with active trial (trialEndsAt in future) -> use subscription tier (pro)
      // 3. If subscription exists with expired trial and no Stripe sub -> free
      // 4. If no subscription row -> free (legacy tenant, pre-migration)
      let effectiveTier: SubscriptionTier;
      if (subscription) {
        if (subscription.stripeSubscriptionId) {
          // Paid subscription -- use the tier from Stripe webhooks
          effectiveTier = subscription.tier;
        } else if (subscription.trialEndsAt && new Date(subscription.trialEndsAt) > new Date()) {
          // Active trial
          effectiveTier = subscription.tier;
        } else {
          // Trial expired, no paid subscription
          effectiveTier = 'free';
        }
      } else {
        // Fall back to tenant's legacy subscriptionTier for backward compatibility
        // This handles tenants that haven't been migrated yet
        effectiveTier = tenant.subscriptionTier ?? 'free';
      }

      const features = getTierFeatures(effectiveTier);

      // Apply overrides (unchanged)
      const overrides = await this.featureOverrideRepo.findByTenantId(tenantId);
      for (const override of overrides) {
        const key = override.featureKey as FeatureKey;
        if (ALL_FEATURE_KEYS.includes(key)) {
          features[key] = override.enabled;
        }
      }

      // Get trial state for frontend
      const trial = await this.trialService.getTrialState(tenantId);

      return { tier: effectiveTier, features, trial };
    }
    ```

    Update `updateTier` method to update org_subscriptions instead of tenants:
    ```typescript
    async updateTier(tenantId: string, tier: SubscriptionTier): Promise<TenantFeaturesResponse> {
      await this.orgSubscriptionRepo.updateTierByTenantId(tenantId, tier);
      return this.getTenantFeatures(tenantId);
    }
    ```

    **Step 2: Update apps/api/src/features/features.module.ts**

    Add imports for TrialModule and DatabaseModule. Add ORG_SUBSCRIPTION_REPOSITORY provider factory:
    ```typescript
    {
      provide: 'ORG_SUBSCRIPTION_REPOSITORY',
      useFactory: (db: any) => new DrizzleOrgSubscriptionRepository(db),
      inject: ['DATABASE'],
    },
    ```

    Import TrialModule so TrialService is injectable.

    **Step 3: Update apps/api/src/features/__tests__/features.service.unit.test.ts**

    Update existing tests to account for the new org_subscriptions lookup and trial state. The mock setup needs to include:
    - orgSubscriptionRepo mock with findByTenantId, updateTierByTenantId
    - trialService mock with getTrialState

    Update existing test expectations:
    - getTenantFeatures should now call orgSubscriptionRepo.findByTenantId
    - Return value now includes `trial` field

    Add new test cases:
    1. **Active trial**: Subscription with trialEndsAt in future -> tier from subscription (pro), trial state included.
    2. **Expired trial no Stripe sub**: trialEndsAt past, no stripeSubscriptionId -> effectiveTier = "free".
    3. **Paid subscription**: Has stripeSubscriptionId -> use subscription tier regardless of trial.
    4. **No subscription row, legacy fallback**: No org_subscriptions row -> fall back to tenant.subscriptionTier.
    5. **Overrides still applied**: Feature overrides work on top of org_subscriptions tier.
    6. **updateTier uses org_subscriptions**: updateTier calls orgSubscriptionRepo.updateTierByTenantId (not tenantRepo.updateTier).
  </action>
  <verify>
    - `pnpm typecheck` passes
    - `pnpm --filter api test` passes (all features tests, including updated ones)
    - `pnpm lint` passes
    - Existing API consumers (frontend) continue to work -- the response shape is backward-compatible (added nullable `trial` field)
    - `curl http://localhost:3000/api/features` (with valid session) returns response with `trial` field
  </verify>
  <done>
    FeaturesService reads tier from org_subscriptions with trial-aware logic. API response includes trial state (active, daysRemaining, endsAt). Legacy tenant.subscriptionTier used as fallback for unmigrated tenants. All existing and new tests pass.
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- `pnpm test` passes (all packages)
- `pnpm lint` passes
- Auth flow triggers trial activation for new orgs
- /features API returns trial state in response
- Expired trial shows tier="free" in response
- Active trial shows tier="pro" in response
- Feature overrides still work
</verification>

<success_criteria>
- New org's first login creates org_subscriptions row with 14-day Pro trial
- Race-safe trial activation (concurrent logins don't create duplicates)
- FeaturesService reads tier from org_subscriptions (not tenants.subscriptionTier)
- Trial expiry handled: past trialEndsAt + no Stripe sub = free tier
- /features API response includes trial state for frontend consumption
- Legacy tenants without org_subscriptions row fall back to tenant.subscriptionTier
- All tests pass (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/14-monetization/14-03-SUMMARY.md`
</output>
