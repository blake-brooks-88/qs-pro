---
phase: 14-monetization
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - apps/api/src/billing/billing.module.ts
  - apps/api/src/billing/stripe.provider.ts
  - apps/api/src/billing/billing.controller.ts
  - apps/api/src/billing/webhook-handler.service.ts
  - apps/api/src/billing/__tests__/webhook-handler.service.unit.test.ts
  - apps/api/src/billing/__tests__/billing.controller.unit.test.ts
  - apps/api/src/main.ts
  - apps/api/src/app.module.ts
autonomous: true
user_setup:
  - service: stripe
    why: "Payment processing for subscriptions"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key (use test key sk_test_... for development)"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint -> Signing secret (whsec_...)"
    dashboard_config:
      - task: "Create webhook endpoint pointing to https://your-api-domain.com/api/billing/webhook"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint"
      - task: "Enable events: checkout.session.completed, customer.subscription.created, customer.subscription.updated, customer.subscription.deleted, invoice.paid, invoice.payment_failed"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Select events"
must_haves:
  truths:
    - "Stripe webhook endpoint at POST /api/billing/webhook processes events from Stripe"
    - "Webhook endpoint verifies Stripe signature before processing"
    - "Webhook endpoint bypasses SessionGuard, CsrfGuard, and throttle"
    - "Duplicate webhook events are detected and skipped via stripe_webhook_events table"
    - "checkout.session.completed creates/updates org subscription with correct tier"
    - "customer.subscription.updated updates tier and period end date"
    - "customer.subscription.deleted downgrades org to free tier"
    - "invoice.payment_failed is logged but does not immediately downgrade"
  artifacts:
    - path: "apps/api/src/billing/billing.module.ts"
      provides: "NestJS BillingModule with all billing providers"
      exports: ["BillingModule"]
    - path: "apps/api/src/billing/stripe.provider.ts"
      provides: "Injectable Stripe SDK client"
      exports: ["STRIPE_CLIENT", "StripeProvider"]
    - path: "apps/api/src/billing/billing.controller.ts"
      provides: "Webhook endpoint with Stripe signature verification"
      exports: ["BillingController"]
    - path: "apps/api/src/billing/webhook-handler.service.ts"
      provides: "Idempotent event routing and org_subscriptions updates"
      exports: ["WebhookHandlerService"]
    - path: "apps/api/src/main.ts"
      provides: "fastify-raw-body registration for webhook route"
      contains: "rawBody"
  key_links:
    - from: "apps/api/src/billing/billing.controller.ts"
      to: "apps/api/src/billing/webhook-handler.service.ts"
      via: "process(event) call after signature verification"
      pattern: "webhookHandler\\.process"
    - from: "apps/api/src/billing/webhook-handler.service.ts"
      to: "packages/database/src/repositories/drizzle-repositories.ts"
      via: "org_subscriptions and stripe_webhook_events repository calls"
      pattern: "orgSubscriptionRepo|webhookEventRepo"
    - from: "apps/api/src/main.ts"
      to: "apps/api/src/billing/billing.controller.ts"
      via: "fastify-raw-body plugin enables req.rawBody on webhook route"
      pattern: "rawBody"
---

<objective>
Implement the Stripe webhook integration that processes payment events and updates org subscriptions.

Purpose: This is the bridge between Stripe's payment infrastructure and the app's tier system. When a customer pays via Stripe Checkout on the external pricing page, a webhook event flows through this module to update the org's subscription tier in real-time.

Output: Complete BillingModule with webhook endpoint, signature verification, idempotent event processing, and unit tests.
</objective>

<execution_context>
@/home/blakebrooks-88/.claude/get-shit-done/workflows/execute-plan.md
@/home/blakebrooks-88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-monetization/14-CONTEXT.md
@.planning/phases/14-monetization/14-RESEARCH.md
@.planning/phases/14-monetization/14-01-SUMMARY.md
@apps/api/src/main.ts
@apps/api/src/app.module.ts
@packages/database/src/schema.ts
@packages/database/src/interfaces/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BillingModule with Stripe SDK, webhook endpoint, and event handler</name>
  <files>
    apps/api/src/billing/billing.module.ts
    apps/api/src/billing/stripe.provider.ts
    apps/api/src/billing/billing.controller.ts
    apps/api/src/billing/webhook-handler.service.ts
    apps/api/src/main.ts
    apps/api/src/app.module.ts
  </files>
  <action>
    **Step 1: Install dependencies**
    ```bash
    pnpm --filter api add stripe fastify-raw-body
    ```

    **Step 2: Create apps/api/src/billing/stripe.provider.ts**

    Create an injectable Stripe client provider:
    ```typescript
    import { ConfigService } from '@nestjs/config';
    import Stripe from 'stripe';

    export const STRIPE_CLIENT = 'STRIPE_CLIENT';

    export const StripeProvider = {
      provide: STRIPE_CLIENT,
      useFactory: (configService: ConfigService): Stripe | null => {
        const secretKey = configService.get<string>('STRIPE_SECRET_KEY');
        if (!secretKey) {
          return null; // Stripe not configured (dev environments)
        }
        return new Stripe(secretKey);
      },
      inject: [ConfigService],
    };
    ```

    Return null when STRIPE_SECRET_KEY is not set so dev environments work. The controller will check for null and return 503 if Stripe is not configured.

    **Step 3: Create apps/api/src/billing/webhook-handler.service.ts**

    This is the core of idempotent webhook processing:

    Constructor injects:
    - ORG_SUBSCRIPTION_REPOSITORY (IOrgSubscriptionRepository)
    - STRIPE_WEBHOOK_EVENT_REPOSITORY (IStripeWebhookEventRepository)
    - AuditService
    - Logger

    `process(event: Stripe.Event)` method:
    1. Call `webhookEventRepo.markProcessing(event.id, event.type)`. If returns false, log debug "Duplicate event skipped" and return (already processed).
    2. Try/catch block routes event by type:
       - `checkout.session.completed`: Extract customer ID and subscription ID from session. Look up metadata for tenant ID (stored in Stripe checkout session metadata). Update org_subscriptions: stripeCustomerId, stripeSubscriptionId, tier based on price/product metadata. Log audit event `subscription.created`.
       - `customer.subscription.updated`: Extract subscription object. Map Stripe subscription status + price to tier. Update org_subscriptions: tier, currentPeriodEnds, seatLimit (from subscription quantity). If status is `past_due` or `unpaid`, keep current tier (graceful degradation per user decision). Log audit event `subscription.updated`.
       - `customer.subscription.deleted`: Find org by stripeCustomerId using `orgSubscriptionRepo.findByStripeCustomerId(customerId)`. Update org_subscriptions: tier = "free", stripeSubscriptionId = null, currentPeriodEnds = null. Log audit event `subscription.canceled`.
       - `invoice.paid`: Update currentPeriodEnds from invoice period_end. Log audit event.
       - `invoice.payment_failed`: Log audit event `subscription.payment_failed`. Do NOT downgrade (per user decision: graceful degradation).
       - Default: Log unhandled event type at debug level.
    3. On success: `webhookEventRepo.markCompleted(event.id)`
    4. On error: `webhookEventRepo.markFailed(event.id, error.message)`, re-throw so Stripe retries

    Helper method `mapStripeTierToSubscriptionTier(priceId: string, productId: string)`: Maps Stripe price/product to "pro" | "enterprise". For v1, use metadata on the Stripe product to store the tier value (e.g., metadata.tier = "pro"). This avoids hardcoding price IDs.

    **Step 4: Create apps/api/src/billing/billing.controller.ts**

    Webhook endpoint controller:

    ```typescript
    @Controller('billing')
    @SkipThrottle() // No rate limiting on Stripe webhooks
    export class BillingController {
      // ...
      @Post('webhook')
      @HttpCode(200)
      async handleWebhook(
        @Req() req: FastifyRequest & { rawBody?: string },
        @Headers('stripe-signature') signature: string,
      ) {
        // Return 503 if Stripe not configured
        if (!this.stripe) {
          throw new ServiceUnavailableException('Stripe not configured');
        }
        // Verify raw body available
        if (!req.rawBody) {
          throw new AppError(ErrorCode.VALIDATION_ERROR, undefined, {
            reason: 'Raw body not available for webhook verification',
          });
        }
        // Verify signature
        const webhookSecret = this.configService.getOrThrow<string>('STRIPE_WEBHOOK_SECRET');
        let event: Stripe.Event;
        try {
          event = this.stripe.webhooks.constructEvent(req.rawBody, signature, webhookSecret);
        } catch (err) {
          this.logger.warn('Stripe webhook signature verification failed');
          throw new AppError(ErrorCode.AUTH_UNAUTHORIZED, undefined, {
            reason: 'Invalid webhook signature',
          });
        }
        // Process event
        await this.webhookHandler.process(event);
        return { received: true };
      }
    }
    ```

    CRITICAL: The webhook controller must NOT use @UseGuards(SessionGuard) or @UseGuards(CsrfGuard). Stripe webhook requests come from Stripe servers, not authenticated users. Security is handled entirely by Stripe signature verification.

    The controller class should NOT have `@UseGuards(SessionGuard)` at the class level. If other endpoints are added later (e.g., portal session), those can add guards individually.

    **Step 5: Create apps/api/src/billing/billing.module.ts**

    NestJS module wiring:
    - Imports: DatabaseModule, AuditModule (for AuditService)
    - Providers: StripeProvider, BillingController, WebhookHandlerService, ORG_SUBSCRIPTION_REPOSITORY factory, STRIPE_WEBHOOK_EVENT_REPOSITORY factory
    - Controllers: [BillingController]
    - Exports: [] (nothing needs to be exported for now; add exports when consumers exist)

    Follow the existing repository injection pattern (useFactory with DATABASE inject):
    ```typescript
    {
      provide: 'ORG_SUBSCRIPTION_REPOSITORY',
      useFactory: (db: any) => new DrizzleOrgSubscriptionRepository(db),
      inject: ['DATABASE'],
    },
    {
      provide: 'STRIPE_WEBHOOK_EVENT_REPOSITORY',
      useFactory: (db: any) => new DrizzleStripeWebhookEventRepository(db),
      inject: ['DATABASE'],
    },
    ```

    Note: No BillingService is created in this plan. The only current consumer is the webhook endpoint, which is fully handled by WebhookHandlerService. A BillingService (e.g., for Stripe Customer Portal sessions) should be added when a controller endpoint or frontend consumer exists, per YAGNI.

    **Step 6: Register fastify-raw-body in apps/api/src/main.ts**

    After `await app.register(formBody);`, add:
    ```typescript
    const rawBodyModule = await import('fastify-raw-body');
    await app.register(rawBodyModule.default, {
      field: 'rawBody',
      global: false,
      encoding: 'utf8',
      runFirst: true,
    });
    ```

    Then add a route hook to enable rawBody specifically for the webhook route:
    ```typescript
    adapter.getInstance().addHook('onRoute', (routeOptions) => {
      if (routeOptions.url === '/api/billing/webhook') {
        routeOptions.config = { ...routeOptions.config, rawBody: true };
      }
    });
    ```

    Place this hook BEFORE the existing onSend hook. If the onRoute approach does not work with NestJS Fastify adapter (per research open question #1), fall back to `global: true` in the plugin registration.

    **Step 7: Add BillingModule to apps/api/src/app.module.ts**

    Import BillingModule in the imports array, after FeaturesModule.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - `pnpm lint` passes
    - API starts without error when STRIPE_SECRET_KEY is not set (null Stripe client, graceful)
    - API starts without error when STRIPE_SECRET_KEY is set (Stripe client created)
    - Verify webhook route exists: `curl -X POST http://localhost:3000/api/billing/webhook` returns 503 (Stripe not configured) or 401 (no signature) -- NOT 401 session required
  </verify>
  <done>
    BillingModule created with StripeProvider, BillingController (webhook endpoint), WebhookHandlerService (idempotent processing of 6 event types). fastify-raw-body registered in main.ts. Webhook endpoint bypasses session/CSRF auth and uses Stripe signature verification. No dead code -- all services have consumers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for webhook handler and billing controller</name>
  <files>
    apps/api/src/billing/__tests__/webhook-handler.service.unit.test.ts
    apps/api/src/billing/__tests__/billing.controller.unit.test.ts
  </files>
  <action>
    **webhook-handler.service.unit.test.ts:**

    Test the WebhookHandlerService with mocked repositories (follow existing test patterns using vi.fn() for repository methods):

    Test cases:
    1. **Idempotency**: When markProcessing returns false (duplicate event), process() returns without calling any handler. Verify no orgSubscriptionRepo calls made.
    2. **checkout.session.completed**: Process a mock Stripe CheckoutSession event. Verify orgSubscriptionRepo.updateFromWebhook called with correct tier, stripeCustomerId, stripeSubscriptionId. Verify webhookEventRepo.markCompleted called.
    3. **customer.subscription.updated**: Process a mock subscription update event. Verify tier mapping works (active -> pro/enterprise based on metadata, past_due -> keeps current tier). Verify currentPeriodEnds updated.
    4. **customer.subscription.deleted**: Process a mock subscription deletion. Verify orgSubscriptionRepo.findByStripeCustomerId called with correct customer ID. Verify tier set to "free", stripeSubscriptionId cleared.
    5. **invoice.payment_failed**: Process a failed payment event. Verify NO tier change (graceful degradation). Verify audit event logged.
    6. **Error handling**: When handler throws, verify markFailed is called with event ID and error message, and error is re-thrown.
    7. **Unhandled event type**: Process an unknown event type. Verify markCompleted called (acknowledge but no action).

    Create mock Stripe event factories for each event type. Use the `Stripe.Event` type for type safety.

    **billing.controller.unit.test.ts:**

    Test the BillingController webhook endpoint:

    1. **No Stripe client**: When STRIPE_CLIENT is null, returns 503 ServiceUnavailable.
    2. **Missing raw body**: When req.rawBody is undefined, returns 400 validation error.
    3. **Invalid signature**: When constructEvent throws, returns 401 unauthorized.
    4. **Valid webhook**: When signature verifies and handler processes, returns { received: true }.
    5. **Missing stripe-signature header**: Returns appropriate error.

    Mock the Stripe SDK's webhooks.constructEvent method. Mock the WebhookHandlerService.process method.

    Follow the existing test patterns in the codebase:
    - Arrange-Act-Assert structure
    - Descriptive test names
    - vi.fn() for mocks
    - Type-safe mock creation
  </action>
  <verify>
    - `pnpm --filter api test` passes
    - Both test files run without errors
    - All test cases pass including idempotency, error handling, and event routing
  </verify>
  <done>
    WebhookHandlerService has unit tests for all 6 event types plus idempotency and error handling. BillingController has unit tests for webhook endpoint including signature verification and edge cases.
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- `pnpm test` passes (all existing + new tests)
- `pnpm lint` passes
- API starts cleanly with and without STRIPE_SECRET_KEY
- Webhook endpoint does NOT require session authentication
- Webhook endpoint returns 200 for valid Stripe events (when Stripe configured)
</verification>

<success_criteria>
- POST /api/billing/webhook processes Stripe events with signature verification
- Webhook endpoint bypasses SessionGuard, CsrfGuard, and throttle
- Duplicate events are detected and skipped
- All 6 event types route to correct org_subscriptions updates
- customer.subscription.deleted uses findByStripeCustomerId to locate org
- Unit tests cover idempotency, error handling, and all event types
- Dev environments work without Stripe keys configured
- No dead code (no unused services or methods)
</success_criteria>

<output>
After completion, create `.planning/phases/14-monetization/14-02-SUMMARY.md`
</output>
