name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  check:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: qs_pro_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

      redis:
        image: redis:alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    env:
      POSTGRES_URL: postgresql://postgres:postgres@localhost:5432/qs_pro_test
      # DATABASE_URL_MIGRATIONS is for migrations + test cleanup only (qs_migrate has BYPASSRLS).
      # Application runtime uses DATABASE_URL (qs_runtime) and must NOT use qs_migrate.
      DATABASE_URL_MIGRATIONS: postgresql://qs_migrate:migrate_pass@localhost:5432/qs_pro_test
      DATABASE_URL: postgresql://qs_runtime:runtime_pass@localhost:5432/qs_pro_test
      REDIS_URL: redis://localhost:6379

    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - run: pnpm install --frozen-lockfile

      - name: Create database roles
        run: |
          psql "$POSTGRES_URL" <<'SQL'
          -- qs_migrate has BYPASSRLS so it is intended ONLY for migrations + test cleanup.
          -- Application runtime must use a non-BYPASSRLS role (qs_runtime).
          CREATE ROLE qs_migrate LOGIN PASSWORD 'migrate_pass' BYPASSRLS;
          CREATE ROLE qs_runtime LOGIN PASSWORD 'runtime_pass';

          -- Harden role attributes explicitly.
          ALTER ROLE qs_migrate BYPASSRLS NOSUPERUSER NOCREATEDB NOCREATEROLE NOREPLICATION;
          ALTER ROLE qs_runtime NOBYPASSRLS NOSUPERUSER NOCREATEDB NOCREATEROLE NOREPLICATION;

          GRANT CONNECT ON DATABASE qs_pro_test TO qs_migrate;
          GRANT CONNECT ON DATABASE qs_pro_test TO qs_runtime;
          GRANT CREATE ON DATABASE qs_pro_test TO qs_migrate;

          GRANT USAGE, CREATE ON SCHEMA public TO qs_migrate;
          GRANT USAGE ON SCHEMA public TO qs_runtime;

          ALTER DEFAULT PRIVILEGES FOR ROLE qs_migrate IN SCHEMA public
            GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO qs_runtime;
          ALTER DEFAULT PRIVILEGES FOR ROLE qs_migrate IN SCHEMA public
            GRANT USAGE, SELECT ON SEQUENCES TO qs_runtime;
          SQL

      - name: Validate DATABASE_URL uses runtime role
        run: |
          if echo "$DATABASE_URL" | grep -q 'qs_migrate'; then
            echo "ERROR: DATABASE_URL must not use qs_migrate" >&2
            exit 1
          fi

      - name: Validate database role privileges
        run: |
          set -euo pipefail

          runtime_privileged=$(psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -tAc \
            "SELECT CASE WHEN (SELECT rolsuper OR rolbypassrls FROM pg_roles WHERE rolname = current_user) THEN 1 ELSE 0 END")
          if [ "$runtime_privileged" != "0" ]; then
            echo "ERROR: Runtime role (DATABASE_URL) must not have SUPERUSER or BYPASSRLS" >&2
            exit 1
          fi

          migrate_correct=$(psql "$DATABASE_URL_MIGRATIONS" -v ON_ERROR_STOP=1 -tAc \
            "SELECT CASE WHEN (SELECT rolbypassrls AND NOT rolsuper FROM pg_roles WHERE rolname = current_user) THEN 1 ELSE 0 END")
          if [ "$migrate_correct" != "1" ]; then
            echo "ERROR: Migrations role (DATABASE_URL_MIGRATIONS) must have BYPASSRLS but not SUPERUSER" >&2
            exit 1
          fi

      - name: Build packages
        run: pnpm -r --filter "./packages/**" build

      - run: pnpm lint

      - run: pnpm typecheck

      - name: Run migrations
        run: pnpm db:migrate

      - name: Unit, integration & e2e tests with coverage
        run: pnpm test:coverage:all

      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: |
            coverage/coverage-summary.json
            coverage/coverage-final.json
          retention-days: 7

  coverage-report:
    needs: check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4

      - name: Download coverage
        uses: actions/download-artifact@v4
        with:
          name: coverage
          path: coverage

      - name: Coverage Report
        uses: davelosert/vitest-coverage-report-action@v2
        with:
          json-summary-path: coverage/coverage-summary.json
          json-final-path: coverage/coverage-final.json
          file-coverage-mode: changes
